name: Force License Sync with Auto-Merge

on:
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
  TARGET_TOPIC: "license-sync"
  FILES_TO_SYNC: '["README.md", "LICENSE", "LICENSE.md"]'
  MAX_MERGE_ATTEMPTS: "3"
  MERGE_DELAY: "10000"

jobs:
  force-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: read

    steps:
      - name: Checkout repositÃ³rio fonte
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Verificar arquivos presentes no repositÃ³rio fonte
        run: |
          echo "Verificando arquivos:"
          MISSING=0
          for file in README.md LICENSE LICENSE.md; do
            if [ -f "$file" ]; then
              echo "âœ… Encontrado: $file"
            else
              echo "âŒ Faltando: $file"
              MISSING=1
            fi
          done
          if [ "$MISSING" -eq 1 ]; then
            echo "ğŸš« Arquivos obrigatÃ³rios ausentes. Abortando sync."
            exit 1
          fi

      - name: Buscar repositÃ³rios com o tÃ³pico
        id: get_repos
        run: |
          response=$(curl -s -H "Authorization: token ${{ env.GITHUB_TOKEN }}" \
            "https://api.github.com/search/repositories?q=topic:${{ env.TARGET_TOPIC }}+user:${{ github.repository_owner }}")

          if echo "$response" | jq -e '.items' > /dev/null; then
            repos=$(echo "$response" | jq -r '.items[].full_name' | tr '\n' ',')
            echo "repos=${repos%,}" >> $GITHUB_OUTPUT
          else
            echo "Erro na API do GitHub:"
            echo "$response" | jq .
            exit 1
          fi

      - name: Sincronizar e Mesclar
        uses: actions/github-script@v6
        with:
          github-token: ${{ env.GITHUB_TOKEN }}
          script: |
            const { promisify } = require('util');
            const sleep = promisify(setTimeout);
            const crypto = require('crypto');
            const fs = require('fs').promises;
            const path = require('path');

            const filesToSync = JSON.parse(process.env.FILES_TO_SYNC);
            const repos = '${{ steps.get_repos.outputs.repos }}'.split(',').filter(Boolean);
            const maxAttempts = parseInt(process.env.MAX_MERGE_ATTEMPTS);
            const mergeDelay = parseInt(process.env.MERGE_DELAY);
            const sourceRepo = '${{ github.repository }}';

            async function tryMerge(owner, repoName, prNumber, attempt = 1) {
              try {
                const { data: pr } = await github.rest.pulls.get({ owner, repo: repoName, pull_number: prNumber });
                if (pr.merged) return true;
                if (attempt >= maxAttempts) return false;

                if (pr.mergeable_state === 'clean') {
                  await github.rest.pulls.merge({
                    owner,
                    repo: repoName,
                    pull_number: prNumber,
                    merge_method: 'squash'
                  });
                  return true;
                }

                console.log(`Tentativa ${attempt}/${maxAttempts}: PR #${prNumber} nÃ£o estÃ¡ pronto (estado: ${pr.mergeable_state})`);
                await sleep(mergeDelay);
                return tryMerge(owner, repoName, prNumber, attempt + 1);
              } catch (error) {
                console.error(`Erro ao tentar merge do PR #${prNumber}:`, error.message);
                return false;
              }
            }

            (async () => {
              for (const repo of repos) {
                if (repo === sourceRepo) {
                  console.log(`ğŸ” Ignorando repositÃ³rio fonte: ${repo}`);
                  continue;
                }

                const [owner, repoName] = repo.split('/');
                const today = new Date().toISOString().slice(0, 10);
                const branchName = `license-sync-bot/${today.replace(/-/g, '')}`;

                try {
                  const { data: repoData } = await github.rest.repos.get({ owner, repo: repoName });
                  const defaultBranch = repoData.default_branch;

                  try {
                    const { data: refData } = await github.rest.git.getRef({
                      owner,
                      repo: repoName,
                      ref: `heads/${defaultBranch}`
                    });

                    await github.rest.git.createRef({
                      owner,
                      repo: repoName,
                      ref: `refs/heads/${branchName}`,
                      sha: refData.object.sha
                    });
                  } catch (e) {
                    if (e.status !== 422) throw e; // branch jÃ¡ existe
                  }

                  let hasChanges = false;
                  for (const file of filesToSync) {
                    const localPath = path.join(process.env.GITHUB_WORKSPACE, file);
                    let localContent;

                    try {
                      localContent = await fs.readFile(localPath, 'utf8');
                    } catch (readErr) {
                      console.warn(`âš ï¸ Arquivo ausente no repositÃ³rio fonte: ${file}`);
                      continue;
                    }

                    const localHash = crypto.createHash('sha1').update(localContent).digest('hex');
                    let needsUpdate = true;

                    try {
                      const { data: remoteFile } = await github.rest.repos.getContent({
                        owner,
                        repo: repoName,
                        path: file,
                        ref: branchName
                      });

                      const remoteContent = Buffer.from(remoteFile.content, 'base64').toString('utf8');
                      const remoteHash = crypto.createHash('sha1').update(remoteContent).digest('hex');

                      needsUpdate = (localHash !== remoteHash);
                    } catch (e) {
                      // File may not exist yet, so we proceed to create it.
                    }

                    if (needsUpdate) {
                      let sha = undefined;
                      try {
                        const { data: remoteFile } = await github.rest.repos.getContent({
                          owner,
                          repo: repoName,
                          path: file
                        });
                        sha = remoteFile.sha;
                      } catch (_) {}

                      await github.rest.repos.createOrUpdateFileContents({
                        owner,
                        repo: repoName,
                        path: file,
                        message: `chore: Atualizar ${file} [skip ci]`,
                        content: Buffer.from(localContent).toString('base64'),
                        sha,
                        branch: branchName,
                        committer: {
                          name: "License Bot",
                          email: "license-bot@users.noreply.github.com"
                        }
                      });

                      console.log(`âœ… Arquivo ${file} sincronizado para ${repo}`);
                      hasChanges = true;
                    } else {
                      console.log(`â„¹ï¸ Arquivo ${file} jÃ¡ estÃ¡ atualizado em ${repo}`);
                    }
                  }

                  if (hasChanges) {
                    const pr = await github.rest.pulls.create({
                      owner,
                      repo: repoName,
                      title: `ğŸ“œ AtualizaÃ§Ã£o de licenÃ§a (${today})`,
                      head: branchName,
                      base: defaultBranch,
                      body: `## AtualizaÃ§Ã£o automÃ¡tica\n\n*Arquivos modificados:*\n${filesToSync.map(f => `- ${f}`).join('\n')}`,
                      draft: false
                    });

                    const merged = await tryMerge(owner, repoName, pr.data.number);
                    console.log(merged ? 'âœ… Merge automÃ¡tico realizado com sucesso.' : 'âš ï¸ Merge nÃ£o realizado automaticamente.');
                  } else {
                    console.log(`ğŸš« Nenhuma mudanÃ§a detectada para ${repo}`);
                  }
                } catch (err) {
                  console.error(`âŒ Erro ao processar repositÃ³rio ${repo}:`, err.message);
                }
              }
            })();
