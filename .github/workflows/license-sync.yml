name: Force License Sync with Pull Request

on:
  workflow_dispatch:  # Execu칞칚o manual segura

env:
  GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
  TARGET_TOPIC: "license-sync"
  FILES_TO_SYNC: '["README.md", "LICENSE", "LICENSE.md"]'

jobs:
  force-sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout reposit칩rio fonte
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Buscar reposit칩rios com o t칩pico
        id: get_repos
        run: |
          response=$(curl -s -H "Authorization: token ${{ env.GITHUB_TOKEN }}" \
            "https://api.github.com/search/repositories?q=topic:${{ env.TARGET_TOPIC }}+user:${{ github.repository_owner }}")
          
          if echo "$response" | jq -e '.items' > /dev/null; then
            repos=$(echo "$response" | jq -r '.items[].full_name' | tr '\n' ',')
            echo "repos=${repos%,}" >> $GITHUB_OUTPUT  # Remove v칤rgula final
          else
            echo "Erro na API do GitHub:"
            echo "$response" | jq .
            exit 1
          fi

      - name: Sincronizar arquivos via API
        uses: actions/github-script@v6
        with:
          github-token: ${{ env.GITHUB_TOKEN }}
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const filesToSync = JSON.parse(process.env.FILES_TO_SYNC);
            const repos = '${{ steps.get_repos.outputs.repos }}'.split(',').filter(Boolean);

            for (const repo of repos) {
              if (repo === '${{ github.repository }}') continue;

              const [owner, repoName] = repo.split('/');
              const today = new Date().toISOString().slice(0, 10);
              const branchName = `license-sync-bot/${today.replace(/-/g, '')}`;

              try {
                // 1. Obter branch padr칚o dinamicamente
                const { data: repoData } = await github.rest.repos.get({ owner, repo: repoName });
                const defaultBranch = repoData.default_branch;

                // 2. Criar branch (se n칚o existir)
                try {
                  const { data: refData } = await github.rest.git.getRef({
                    owner,
                    repo: repoName,
                    ref: `heads/${defaultBranch}`
                  });
                  await github.rest.git.createRef({
                    owner,
                    repo: repoName,
                    ref: `refs/heads/${branchName}`,
                    sha: refData.object.sha
                  });
                } catch (e) {
                  if (e.status !== 422) throw e; // Ignora se branch j치 existe
                }

                // 3. Atualizar arquivos
                let hasChanges = false;
                for (const file of filesToSync) {
                  try {
                    const filePath = path.join(process.env.GITHUB_WORKSPACE, file);
                    const content = await fs.readFile(filePath, 'utf8');
                    const encodedContent = Buffer.from(content).toString('base64');

                    // Verifica se o conte칰do atual 칠 diferente
                    let currentSha = null;
                    try {
                      const { data } = await github.rest.repos.getContent({
                        owner,
                        repo: repoName,
                        path: file,
                        ref: branchName
                      });
                      currentSha = data.sha;
                    } catch (e) { /* Arquivo pode n칚o existir ainda */ }

                    if (!currentSha || currentSha !== require('crypto').createHash('sha1').update(content).digest('hex')) {
                      await github.rest.repos.createOrUpdateFileContents({
                        owner,
                        repo: repoName,
                        path: file,
                        message: `chore: Atualizar ${file} [skip ci]`,
                        content: encodedContent,
                        branch: branchName,
                        sha: currentSha,
                        committer: {
                          name: "License Bot",
                          email: "license-bot@users.noreply.github.com"
                        }
                      });
                      hasChanges = true;
                    }
                  } catch (error) {
                    core.warning(`Falha em ${file}@${repoName}: ${error.message}`);
                  }
                }

                // 4. Criar PR apenas se houver mudan칞as
                if (hasChanges) {
                  await github.rest.pulls.create({
                    owner,
                    repo: repoName,
                    title: `游닆 Atualiza칞칚o de licen칞a (${today})`,
                    head: branchName,
                    base: defaultBranch,
                    body: `## 游늯 Atualiza칞칚o autom치tica\n\nArquivos modificados:\n- ${filesToSync.map(f => \`\${f}\`).join('\n- ')}\n\n*Atualiza칞칚o autom치tica acionada pelo [GitHub Actions](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})*`
                  });
                } else {
                  console.log(`Nenhuma altera칞칚o necess치ria em ${repoName}`);
                }

              } catch (error) {
                core.error(`Erro cr칤tico em ${repoName}: ${error.message}`);
              }
            }
