name: Force License Sync with Push to Main

on:
  workflow_dispatch:  # Execução manual segura

env:
  GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
  TARGET_TOPIC: "license-sync"
  FILES_TO_SYNC: '["README.md", "LICENSE", "LICENSE.md"]'

jobs:
  force-sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repositório fonte
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Buscar repositórios com o tópico
        id: get_repos
        run: |
          response=$(curl -s -H "Authorization: token ${{ env.GITHUB_TOKEN }}" \
            "https://api.github.com/search/repositories?q=topic:${{ env.TARGET_TOPIC }}+user:${{ github.repository_owner }}")
          
          if echo "$response" | jq -e '.items' > /dev/null; then
            repos=$(echo "$response" | jq -r '.items[].full_name' | tr '\n' ',')
            echo "repos=${repos%,}" >> $GITHUB_OUTPUT  # Remove vírgula final
          else
            echo "Erro na API do GitHub:" 
            echo "$response" | jq .
            exit 1
          fi

      - name: Sincronizar arquivos via API
        uses: actions/github-script@v6
        with:
          github-token: ${{ env.GITHUB_TOKEN }}
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const filesToSync = JSON.parse(process.env.FILES_TO_SYNC);
            const repos = '${{ steps.get_repos.outputs.repos }}'.split(',').filter(Boolean);

            for (const repo of repos) {
              if (repo === '${{ github.repository }}') continue;

              const [owner, repoName] = repo.split('/');
              const today = new Date().toISOString().slice(0, 10);
              const branchName = `license-sync-bot/${today.replace(/-/g, '')}`;

              try {
                // Usando a branch `main` diretamente
                const defaultBranch = 'main';

                // 1. Criar branch temporária (se não existir)
                let sha;
                try {
                  const { data: refData } = await github.rest.git.getRef({
                    owner,
                    repo: repoName,
                    ref: `heads/${defaultBranch}`
                  });
                  await github.rest.git.createRef({
                    owner,
                    repo: repoName,
                    ref: `refs/heads/${branchName}`,
                    sha: refData.object.sha
                  });
                  sha = refData.object.sha; // Salvando o SHA da branch principal
                } catch (e) {
                  if (e.status !== 422) throw e; // Ignora se branch já existe
                  // Se a branch já existir, pegamos o sha da última commit da branch
                  const { data: refData } = await github.rest.git.getRef({
                    owner,
                    repo: repoName,
                    ref: `heads/${branchName}`
                  });
                  sha = refData.object.sha;
                }

                // 2. Atualizar os arquivos
                let hasChanges = false;
                for (const file of filesToSync) {
                  try {
                    const filePath = path.join(process.env.GITHUB_WORKSPACE, file);
                    const content = await fs.readFile(filePath, 'utf8');
                    const encodedContent = Buffer.from(content).toString('base64');

                    // Verifica se o conteúdo atual é diferente
                    let currentSha = null;
                    try {
                      const { data } = await github.rest.repos.getContent({
                        owner,
                        repo: repoName,
                        path: file,
                        ref: branchName
                      });
                      currentSha = data.sha;
                    } catch (e) { /* Arquivo pode não existir ainda */ }

                    if (!currentSha || currentSha !== require('crypto').createHash('sha1').update(content).digest('hex')) {
                      const updateResponse = await github.rest.repos.createOrUpdateFileContents({
                        owner,
                        repo: repoName,
                        path: file,
                        message: `chore: Atualizar ${file} [skip ci]`,
                        content: encodedContent,
                        branch: branchName,
                        sha: currentSha,
                        committer: {
                          name: "License Bot",
                          email: "license-bot@users.noreply.github.com"
                        }
                      });
                      hasChanges = true;
                      sha = updateResponse.data.commit.sha; // Atualizando o sha com o novo commit
                    }
                  } catch (error) {
                    core.warning(`Falha em ${file}@${repoName}: ${error.message}`);
                  }
                }

                // 3. Forçar o push para a branch `main` se houver mudanças
                if (hasChanges) {
                  console.log(`Alterações detectadas em ${repoName}. Forçando push na branch main.`);

                  // Push direto na branch `main`
                  await github.rest.git.updateRef({
                    owner,
                    repo: repoName,
                    ref: `heads/${defaultBranch}`,
                    sha: sha // Usando o sha atualizado
                  });

                  console.log(`Push forçado para a branch ${defaultBranch} em ${repoName}`);
                } else {
                  console.log(`Nenhuma alteração necessária em ${repoName}`);
                }

              } catch (error) {
                core.error(`Erro crítico em ${repoName}: ${error.message}`);
              }
            }
