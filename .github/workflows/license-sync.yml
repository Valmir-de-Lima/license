name: Sincronizar Licenças e README

on:
  workflow_dispatch:

jobs:
  update_files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repositório atual
        uses: actions/checkout@v2

      - name: Sincronizar arquivos com push forçado para a branch principal (main)
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { promisify } = require('util');
            const sleep = promisify(setTimeout);
            const fs = require('fs').promises;
            const path = require('path');

            const filesToSync = ['README.md', 'LICENSE', 'LICENSE.md'];  // Lista de arquivos a sincronizar
            const repos = ['AppTestClienteCore', 'cliente-core'];  // Lista de repositórios de destino
            const maxAttempts = 3;  // Número máximo de tentativas
            const pushDelay = 3000;  // Delay entre tentativas

            async function forcePushToMain(owner, repoName, branchName, filesToSync) {
              const today = new Date().toISOString().slice(0, 10);
              const commitMessage = `chore: Atualizar arquivos de licença e README (${today})`;

              let hasChanges = false;
              for (const file of filesToSync) {
                try {
                  const filePath = path.join(process.env.GITHUB_WORKSPACE, file);
                  const localContent = await fs.readFile(filePath, 'utf8');

                  let sha = undefined;
                  try {
                    const { data: remoteFile } = await github.rest.repos.getContent({
                      owner,
                      repo: repoName,
                      path: file,
                      ref: 'main'
                    });
                    sha = remoteFile.sha;
                  } catch (e) {
                    // Arquivo não existe
                    console.warn(`Arquivo ${file} não existe em ${repoName}, será criado.`);
                  }

                  // Cria ou atualiza o arquivo
                  await github.rest.repos.createOrUpdateFileContents({
                    owner,
                    repo: repoName,
                    path: file,
                    message: commitMessage,
                    content: Buffer.from(localContent).toString('base64'),
                    branch: 'main',  // Commit forçado na branch 'main'
                    ...(sha ? { sha } : {}),
                    committer: {
                      name: "License Bot",
                      email: "license-bot@users.noreply.github.com"
                    }
                  });

                  hasChanges = true;
                  console.log(`✅ Arquivo ${file} sincronizado com sucesso em ${repoName}`);
                } catch (error) {
                  console.warn(`❌ Falha ao sincronizar ${file}@${repoName}:`, error.message);
                }
              }

              if (hasChanges) {
                try {
                  // Forçar o push para a branch 'main'
                  await github.rest.git.createRef({
                    owner,
                    repo: repoName,
                    ref: `refs/heads/main`,  // Forçar push para a branch 'main'
                    sha: 'latest-sha-from-source-repo',  // Use o SHA mais recente da branch base ou principal
                  });
                  console.log(`✅ Push forçado realizado para o repositório ${repoName} na branch main`);
                } catch (error) {
                  console.error(`❌ Erro ao forçar o push para ${repoName}:`, error.message);
                }
              }
            }

            async function processRepos() {
              for (const repo of repos) {
                const owner = 'valmirblima';  // Seu nome de usuário
                const repoName = repo;

                try {
                  // Sincronização dos arquivos com push forçado para 'main'
                  await forcePushToMain(owner, repoName, 'main', filesToSync);
                } catch (error) {
                  console.error(`Erro em ${repoName}:`, error.message);
                }
              }
            }

            processRepos();
