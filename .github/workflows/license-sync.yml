name: Force License Sync with Push to Main

on:
  workflow_dispatch:  # Execu√ß√£o manual

env:
  GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
  TARGET_TOPIC: "license-sync"
  FILES_TO_SYNC: '["README.md", "LICENSE", "LICENSE.md"]'

jobs:
  force-sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout do reposit√≥rio fonte
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Buscar reposit√≥rios com o t√≥pico
        id: get_repos
        run: |
          response=$(curl -s -H "Authorization: token ${{ env.GITHUB_TOKEN }}" \
            "https://api.github.com/search/repositories?q=topic:${{ env.TARGET_TOPIC }}+user:${{ github.repository_owner }}")
          
          if echo "$response" | jq -e '.items' > /dev/null; then
            repos=$(echo "$response" | jq -r '.items[].full_name' | tr '\n' ',')
            echo "repos=${repos%,}" >> $GITHUB_OUTPUT
          else
            echo "Erro na API do GitHub:"
            echo "$response" | jq .
            exit 1
          fi

      - name: Sincronizar arquivos com push for√ßado
        uses: actions/github-script@v6
        with:
          github-token: ${{ env.GITHUB_TOKEN }}
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            const crypto = require('crypto');

            const filesToSync = JSON.parse(process.env.FILES_TO_SYNC);
            const repos = '${{ steps.get_repos.outputs.repos }}'.split(',').filter(Boolean);
            const defaultBranch = 'main';

            for (const repo of repos) {
              if (repo === '${{ github.repository }}') continue;

              const [owner, repoName] = repo.split('/');
              console.log(`üîÑ Verificando ${repoName}...`);

              try {
                const { data: latestCommit } = await github.rest.repos.getCommit({
                  owner,
                  repo: repoName,
                  ref: `heads/${defaultBranch}`,
                });

                const baseTree = latestCommit.commit.tree.sha;

                let hasChanges = false;
                const blobs = [];

                for (const file of filesToSync) {
                  try {
                    const filePath = path.join(process.env.GITHUB_WORKSPACE, file);
                    const content = await fs.readFile(filePath, 'utf8');

                    // Tenta buscar conte√∫do existente no reposit√≥rio destino
                    let shouldUpdate = true;
                    try {
                      const { data: currentData } = await github.rest.repos.getContent({
                        owner,
                        repo: repoName,
                        path: file,
                        ref: defaultBranch
                      });

                      const currentContent = Buffer.from(currentData.content, 'base64').toString('utf-8');
                      const hashOld = crypto.createHash('sha256').update(currentContent).digest('hex');
                      const hashNew = crypto.createHash('sha256').update(content).digest('hex');
                      if (hashOld === hashNew) {
                        shouldUpdate = false;
                      }
                    } catch (_) {
                      // Arquivo pode n√£o existir ainda
                    }

                    if (shouldUpdate) {
                      console.log(`üìù Altera√ß√µes detectadas em ${file} no reposit√≥rio ${repoName}.`);
                      const blob = await github.rest.git.createBlob({
                        owner,
                        repo: repoName,
                        content,
                        encoding: "utf-8",
                      });
                      blobs.push({
                        path: file,
                        mode: "100644",
                        type: "blob",
                        sha: blob.data.sha,
                      });
                      hasChanges = true;
                    }
                  } catch (error) {
                    console.warn(`‚ö†Ô∏è Erro ao processar ${file} em ${repoName}: ${error.message}`);
                  }
                }

                if (!hasChanges) {
                  console.log(`‚úÖ Nenhuma altera√ß√£o necess√°ria em ${repoName}.`);
                  continue;
                }

                const tree = await github.rest.git.createTree({
                  owner,
                  repo: repoName,
                  base_tree: baseTree,
                  tree: blobs,
                });

                const commit = await github.rest.git.createCommit({
                  owner,
                  repo: repoName,
                  message: `chore: Atualiza√ß√£o de arquivos de licen√ßa [skip ci]`,
                  tree: tree.data.sha,
                  parents: [latestCommit.sha],
                });

                await github.rest.git.updateRef({
                  owner,
                  repo: repoName,
                  ref: `heads/${defaultBranch}`,
                  sha: commit.data.sha,
                  force: true,
                });

                console.log(`üöÄ Push for√ßado conclu√≠do para ${repoName}`);

              } catch (error) {
                core.error(`‚ùå Erro cr√≠tico em ${repoName}: ${error.message}`);
              }
            }
