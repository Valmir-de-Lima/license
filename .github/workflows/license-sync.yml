name: Force License Sync with Auto-Merge

on:
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
  TARGET_TOPIC: "license-sync"
  FILES_TO_SYNC: '["README.md", "LICENSE", "LICENSE.md"]'
  MAX_MERGE_ATTEMPTS: "3"  # M치ximo de tentativas de merge
  MERGE_DELAY: "10000"     # 10 segundos entre tentativas

jobs:
  force-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: read

    steps:
      # ... (passos de checkout e get_repos mantidos iguais)

      - name: Sincronizar e Mesclar
        uses: actions/github-script@v6
        with:
          github-token: ${{ env.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');
            const crypto = require('crypto');
            const fs = require('fs').promises;
            const path = require('path');

            const filesToSync = JSON.parse(process.env.FILES_TO_SYNC);
            const repos = '${{ steps.get_repos.outputs.repos }}'.split(',').filter(Boolean);
            const maxAttempts = parseInt(process.env.MAX_MERGE_ATTEMPTS);
            const mergeDelay = parseInt(process.env.MERGE_DELAY);

            async function tryMerge(owner, repoName, prNumber, attempt = 1) {
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner,
                  repo: repoName,
                  pull_number: prNumber
                });

                if (pr.merged) {
                  console.log(`PR #${prNumber} j치 mesclado`);
                  return true;
                }

                if (pr.mergeable_state === 'clean' && pr.state === 'open') {
                  await github.rest.pulls.merge({
                    owner,
                    repo: repoName,
                    pull_number: prNumber,
                    merge_method: 'squash'
                  });
                  return true;
                }

                if (attempt >= maxAttempts) {
                  core.warning(`M치ximo de tentativas (${maxAttempts}) atingido para PR #${prNumber}`);
                  return false;
                }

                console.log(`Tentativa ${attempt}/${maxAttempts}: PR n칚o est치 pronto para merge (estado: ${pr.mergeable_state})`);
                await new Promise(r => setTimeout(r, mergeDelay));
                return tryMerge(owner, repoName, prNumber, attempt + 1);
              } catch (error) {
                core.error(`Erro no merge do PR #${prNumber}: ${error.message}`);
                return false;
              }
            }

            for (const repo of repos) {
              if (repo === '${{ github.repository }}') continue;

              const [owner, repoName] = repo.split('/');
              const today = new Date().toISOString().slice(0, 10);
              const branchName = `license-sync-bot/${today.replace(/-/g, '')}`;

              try {
                // 1. Obter branch padr칚o
                const { data: repoData } = await github.rest.repos.get({ owner, repo: repoName });
                const defaultBranch = repoData.default_branch;

                // 2. Criar branch
                try {
                  const { data: refData } = await github.rest.git.getRef({
                    owner,
                    repo: repoName,
                    ref: `heads/${defaultBranch}`
                  });
                  await github.rest.git.createRef({
                    owner,
                    repo: repoName,
                    ref: `refs/heads/${branchName}`,
                    sha: refData.object.sha
                  });
                } catch (e) {
                  if (e.status !== 422) throw e;
                }

                // 3. Atualizar arquivos
                let hasChanges = false;
                for (const file of filesToSync) {
                  try {
                    const filePath = path.join(process.env.GITHUB_WORKSPACE, file);
                    const localContent = await fs.readFile(filePath, 'utf8');
                    
                    // Verifica칞칚o mais robusta de mudan칞as
                    let needsUpdate = true;
                    try {
                      const { data: remoteFile } = await github.rest.repos.getContent({
                        owner,
                        repo: repoName,
                        path: file,
                        ref: branchName
                      });
                      const remoteContent = Buffer.from(remoteFile.content, 'base64').toString('utf8');
                      needsUpdate = (remoteContent !== localContent);
                    } catch (e) {
                      needsUpdate = true;
                    }

                    if (needsUpdate) {
                      await github.rest.repos.createOrUpdateFileContents({
                        owner,
                        repo: repoName,
                        path: file,
                        message: `chore: Atualizar ${file} [skip ci]`,
                        content: Buffer.from(localContent).toString('base64'),
                        branch: branchName,
                        committer: {
                          name: "License Bot",
                          email: "license-bot@users.noreply.github.com"
                        }
                      });
                      hasChanges = true;
                    }
                  } catch (error) {
                    core.warning(`Falha em ${file}@${repoName}: ${error.message}`);
                  }
                }

                // 4. Criar e mesclar PR
                if (hasChanges) {
                  const pr = await github.rest.pulls.create({
                    owner,
                    repo: repoName,
                    title: `游닆 Atualiza칞칚o de licen칞a (${today})`,
                    head: branchName,
                    base: defaultBranch,
                    body: `## Atualiza칞칚o autom치tica\n\n*Arquivos modificados:*\n${filesToSync.map(f => `- ${f}`).join('\n')}`,
                    draft: false
                  });

                  const prNumber = pr.data.number;
                  const mergeSuccess = await tryMerge(owner, repoName, prNumber);
                  
                  if (!mergeSuccess) {
                    core.notice(`PR #${prNumber} n칚o p칪de ser mesclado automaticamente em ${repoName}`);
                  }
                } else {
                  console.log(`Nenhuma mudan칞a necess치ria em ${repoName}`);
                }

              } catch (error) {
                core.error(`Erro cr칤tico em ${repoName}: ${error.message}`);
              }
            }
